(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{456:function(v,_,e){"use strict";e.r(_);var o=e(54),c=Object(o.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"solid-五大设计原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#solid-五大设计原则"}},[v._v("#")]),v._v(" SOLID 五⼤设计原则")]),v._v(" "),e("ol",[e("li",[e("p",[v._v("SOLID，\n"),e("code",[v._v("S")]),v._v("表⽰单⼀职责原则，\n"),e("code",[v._v("O")]),v._v("表⽰开放封原则，\n"),e("code",[v._v("L")]),v._v("表⽰李⽒置换原则，\n"),e("code",[v._v("I")]),v._v("表⽰接⼝独⽴原则，\n"),e("code",[v._v("D")]),v._v("表⽰依赖导致原则。")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("S")]),v._v(" 表⽰单⼀职责原则，⼀个程序只做好⼀件事。如果功能过于复杂就拆分开，每个部分保持独⽴。")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("O")]),v._v("表⽰开放封原则，对扩展开放，对修改封闭。增加需求时，扩展新代码，⽽⾮修改已有代码。这是软件设计的终极⽬标。")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("L")]),v._v("表⽰李⽒置换原则，⼦类能覆盖⽗类，⽗类出现的地⽅⼦类就能出现。"),e("code",[v._v("JS")]),v._v("中使⽤较少，弱类型和继承使⽤较少。")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("I")]),v._v(' 表⽰接⼝独⽴原则，保持接⼝的单⼀独⽴，避免出现"胖接⼝"。'),e("code",[v._v("JS")]),v._v(" 中没有接⼝，"),e("code",[v._v("Typescript")]),v._v(" 例外，使⽤较少。类似于单⼀职责原则，这⾥更关注接⼝。")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("D")]),v._v(" 表⽰依赖导致原则，⾯向接⼝编程，依赖于抽象⽽不依赖于具体。使⽤⽅法只关注接⼝⽽不关注具体类的实现。"),e("code",[v._v("JS")]),v._v(" 中使⽤较少，没有接⼝和弱类型。")])]),v._v(" "),e("li",[e("p",[v._v("设计原则的总结，"),e("code",[v._v("SO")]),v._v(" 体现较多，需要理解，"),e("code",[v._v("LID")]),v._v(" 体现较少，需要了解。")])]),v._v(" "),e("li",[e("p",[v._v("⽤"),e("code",[v._v("Promise")]),v._v(" 来说明 "),e("code",[v._v("SO")]),v._v("，如下所⽰：")])])]),v._v(" "),e("p",[v._v("单⼀职责原则，每个"),e("code",[v._v("then")]),v._v(" 中的逻辑只做好⼀件事")]),v._v(" "),e("p",[e("code",[v._v("then")]),v._v("开放封闭原则，如果新增需求，扩展")]),v._v(" "),e("p",[v._v("对扩展开放，对修改封闭")])])}),[],!1,null,null,null);_.default=c.exports}}]);